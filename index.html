<!DOCTYPE html>
<html>
<head>
    <title>Smart Move</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.7.1/dist/leaflet.css" />
    <style>
        /* Estilos mejorados */
        #nextStopInfo {
            margin: 15px 0;
            padding: 10px;
            background: #e9ecef;
            border-radius: 5px;
        }
        .progress-line {
            height: 4px;
            background: #dee2e6;
            margin: 10px 0;
            position: relative;
        }
        .progress-indicator {
            height: 100%;
            background: #28a745;
            width: 0;
            transition: width 0.3s ease;
        }
    </style>
</head>
<body>
    <!-- Añadido progreso y info de parada -->
    <div class="progress-line">
        <div class="progress-indicator" id="routeProgress"></div>
    </div>
    <div id="nextStopInfo">
        Próxima parada: <strong id="nextStopName">-</strong><br>
        Hora programada: <span id="nextStopTime">-</span>
    </div>

    <script>
        // Variables mejoradas
        let hasEnteredProximity = false;
        let routePolyline, routeMarkers = [];

        // Nuevo método para análisis de dirección
        function isMovingTowards(currentPos, nextStop) {
            if (!window.previousPosition) return true;
            const prevDist = getDistance(window.previousPosition, nextStop);
            const currentDist = getDistance(currentPos, nextStop);
            return currentDist < prevDist;
        }

        // Actualización de navegación
        function updateNavigation() {
            const nextStop = currentRoute.stops[currentStopIndex];
            const now = new Date();
            
            // Calcular diferencia horaria precisa
            const scheduledTime = parseTime(nextStop.time);
            const timeDiff = scheduledTime - now;
            
            // Actualizar progreso
            const totalStops = currentRoute.stops.length;
            const progress = (currentStopIndex / (totalStops - 1)) * 100;
            document.getElementById('routeProgress').style.width = `${progress}%`;
        }

        // Mejorado sistema de carga de rutas
        function loadRoute(index) {
            // Limpiar elementos anteriores del mapa
            if (routePolyline) map.removeLayer(routePolyline);
            routeMarkers.forEach(marker => map.removeLayer(marker));
            
            // Cargar nueva ruta
            currentRoute = routes[index];
            const latlngs = currentRoute.stops.map(stop => [stop.lat, stop.lng]);
            
            // Dibujar nueva ruta
            routePolyline = L.polyline(latlngs, {color: 'blue'}).addTo(map);
            routeMarkers = currentRoute.stops.map(stop => 
                L.marker([stop.lat, stop.lng]).addTo(map)
            );
            
            map.fitBounds(routePolyline.getBounds());
        }
    </script>
</body>
</html>
